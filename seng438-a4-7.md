**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#4 â€“ Mutation Testing and Web app testing**

| Group 7:      |     |
| -------------- | --- |
| Student Names: |     |
| Jack Rovere                |   30085670  |
| Brenek Spademan              | 30060822 |
|                |     |

# Introduction


# Analysis of 10 Mutants of the Range class 
<img width="824" alt="Screen Shot 2023-03-15 at 9 33 27 AM" src="https://user-images.githubusercontent.com/101214266/225360703-685c4346-5bed-4dcb-98a3-c702597d548b.png">
As can be seen in picture above there is 10 mutants of getCentralValue where the first four mutants survive and the last six mutants are killed. The first four survive as this.lower/this.upper are incremented/decremented after they are used in the return statement, so it does not affect what the function returns, and as such will not cause a test case to fail. The the last six mutants are killed as they cause what the function returns to change, so they result in test cases failing. 

# Report all the statistics and the mutation score for each test class

<img width="624" alt="image" src="https://user-images.githubusercontent.com/98235387/225403129-57d08aec-52a2-4b69-8a96-e138dca3f7f9.png">

<img width="1065" alt="Screen Shot 2023-03-15 at 9 49 32 AM" src="https://user-images.githubusercontent.com/101214266/225365282-bf9a50d4-d137-4a23-be15-1b8b38ce9bd3.png">




# Analysis drawn on the effectiveness of each of the test classes

The effectiveness of the DataUtilities test suite was originally 85%. This was very high, which was a big indicator to us that we had achieved an effective creation of our test case.

The effectiveness of the Range test suite was originally 61%. This was quite mediocre, which was an indicaton that although our test had achieved high statement and branch coverage, it did not thoroughly test all possible inputs. 

# A discussion on the effect of equivalent mutants on mutation score accuracy

Equivalent mutants are mutants that have no semantic effect on the overall functionality of the code. Because of this, equivalent mutants appear to be an indicator of a fault with the code, when in reality this is untrue. Because of these equivalent mutants, it is basically impossible to achieve 100% mutation coverage. Therefore, it can be said that equivalent mutants have a negative overall effect on mutation score accuracy in a program under test.

__Equivalent Mutants in DataUtilities:__

DataUtilities (Line 104): for (int i = 0; i < source.length; i++) { ------> for (int i = 0; i != source.length; i++) {<br>
DataUtilities (Line 178): for (int c = 0; c < columnCount; c++) { ------> for (int c = 0; c != columnCount; c++) {<br>
DataUtilities (Line 245): for (int i = 0; i < l1; i++) { ------> for (int i = 0; i != l1; i++) {

__Equivalent Mutants in Range:__ 

Range (Line 430): if (!(this.lower == range.lower)) { --> if ((this.lower != range.lower)) { <br>
Range (Line 433): if (!(this.upper == range.upper)) { --> if ((this.upper != range.upper)) { <br>

__How we found equivalent mutations:__

To find equivalent mutations, we looked at the PITEST summary of the files. We checked for all the mutations that survived, because equivalent mutations cannot be killed, as they mimic the correct functionality of the program. When looking at these surviving mutations, we checked the conditions and if they seemed to be equivalent, we tested this functionality manually by changing the code itself (we then changed it back afterwards for consistency).

# A discussion of what could have been done to improve the mutation score of the test suites

It was found that many of the mutations that survived, would have been killed if there was more test cases to test the boundaries of a method. Particularily with the Range class (but also with DataUtilities to a lesser degree), the mutation score was lower as there was many boundary conditions that were not tested. By adding more test cases to test the boundaries of various methods for both classes, more mutations were killed by the test suite. This resulted in the mutation coverage increasing as more boundary value conditions were tested. 

# Mutation Coverage After Changes

__DataUtilities:__<br>

<img width="608" alt="image" src="https://user-images.githubusercontent.com/98235387/225173831-b920ced6-33ec-4e92-8bef-07d1a13d7eda.png">

__Range:__<br>

<img width="1109" alt="Screen Shot 2023-03-15 at 10 19 22 AM" src="https://user-images.githubusercontent.com/101214266/225373772-fd5f1a11-4bcc-4b4f-96c9-2a854f757496.png">


# Why do we need mutation testing? Advantages and disadvantages of mutation testing

Mutation testing is very important in ensuring that the test cases written by software engineers is reliably testing the code, and not just generating a bunch of false positives. Combining a mutation score with line coverage and branch coverage scores helps show a more complete picture of the unit tests being written. For example, if a test suite was built up of test cases that passed on a overly wide range of values, it wouldn't be a good indicator of the program's success as many errors could be perceived by the program as successes. With mutation testing, we can see how strong the test code really is if there are small changes introduced, as a well designed program will be able to react to these relatively discrete mutations with ease.

# Explain your SELENUIM test case design process
__"Add item to cart"__:
The functionality this test is considering is the ability to enter the correct website, browse for an item, and then ad the item to the cart. No functionality following the additon of an item to the cart is tested in this test case. An item is selected from the list of options and then the add-to-cart button is selected. Item browsing is tested using a search for a key-word in the search bar, as well browsing through different catagories starting from the homepage. 

__"Add to cart & Edit cart"__:
The functionality this test is considering is the ability to enter the correct website, browse for an item, and then ad the item to the cart. Next, the cart is opened and the item that was just added to the cart is then removed, updating the contents of the cart. 

__"Change Country"__:
The functionality this test is considering is the ability to enter the correct website and select a country of origin on the website. Changing from one country to another is the same process regardless of location, so testing once instance where a different country is selected ensures a working system for other country changes. 

__"Change Language"__:
The functionality this test is considering is the ability to enter the correct website and change the language of the site to whatever is desired by the user. The test consdiers altering the French/English language option on the home page, as well as selecting a country with a different language, and seeing if the website updates to the language of the selected country. 

# Explain the use of assertions and checkpoints

# how did you test each functionaity with different test data
__"Add item to cart"__:
The functionality of adding an item to the cart ws tested by selecting different items from various catagories of products on the website to the cart. The user chooses to either select the "add to cart" button or not, and so to ensure this funciton  is consistant, different items and their ability to be added were considered.  

__"Add to cart & Edit cart"__:


__"Change Country"__:


__"Change Language"__:

# Discuss advantages and disadvantages of Selenium vs. Sikulix

# How the team work/effort was divided and managed

For the mutation testing part of this lab, Brenek and Ben worked on the Range class while Jack and Arion worked on DataUtilities. For the GUI testing portion of this lab, we all worked together to ensure we had developed different test cases, and that we all understood how to use Selenium.

# Difficulties encountered, challenges overcome, and lessons learned

A diffuculty encountered in this lab was figuring out how to improve our mutation coverage, so that more mutations would be killed. This challenge was overcome by discovering that many of the surviving mutants survived because boundary conditions were not tested. Through this lab we learned the importance of testing boundary conditions.

# Comments/feedback on the lab itself

This lab we very enjoyable, and we all felt that it helped to prepare us for the course final, as we improved our understanding of mutation and GUI testing.


